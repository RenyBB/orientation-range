<!DOCTYPE html>
<html>
    <head>
  	<script src="https://unpkg.com/jspsych"></script>
  	<script src="https://unpkg.com/@jspsych/plugin-html-button-response"></script>
  	<script src="https://unpkg.com/@jspsych/plugin-audio-button-response"></script>	    
	<script src="https://unpkg.com/@jspsych/plugin-preload"></script>
	<script src="https://unpkg.com/@jspsych/plugin-browser-check@1.0.1"></script>
	<script src="https://unpkg.com/@jspsych/plugin-virtual-chinrest@2.0.1"></script>
  	<script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response"></script>
	<script src="https://unpkg.com/@jspsych/plugin-html-button-response"></script>
  	<script src="https://unpkg.com/@jspsych/plugin-image-keyboard-response"></script>
    	<script src="https://unpkg.com/@jspsych/plugin-instructions"></script>	    
        <script src="https://unpkg.com/@jspsych/plugin-call-function"></script>
	<script src="stimulus_list.js"></script>
	    
      	<script src="jspsych-psychophysics.js"></script>
      	<script src="https://pixijs.download/release/pixi.js"></script>
	    
  	<link rel="stylesheet" href="https://unpkg.com/jspsych@7.1.2/css/jspsych.css"/>  
	<style>
      		html,body {
        	background-color: #808080;
        	color: white;
      		}
  	</style>
    </head>
    <body></body>
    <script>
	    
	    
// This experiment contains 2 tasks: an orientation matching/reproduction task and an orientation discrimination task
/* In the orientation matching task, participants see a grating and after the grating disappears they have to rotate a line to match the orientation of the grating.
   In the orientation discrimination task, participants see two pairs of gratings and have to decide which are more similar in orientation. 
*/	    
	    // Initialize jspsych
	    const jsPsych = initJsPsych({
		    show_progress_bar: true,
		    auto_update_progress_bar: false,
		    on_interaction_data_update: function(data) {
			    console.log(JSON.stringify(data))},
		    on_finish: function() {
			    jsPsych.data.displayData();
		    }
	    });
	    
	    // Count total number of trials across the two tasks
	    const reproduction_training_stimulus_repetitions = 3; 
	    const reproduction_testing_stimulus_repetitions = 3; // to change
	    const discrimination_training_stimulus_repetitions = 3;
	    const discrimination_testing_stimulus_repetitions = 2; // DO NOT CHANGE
	    
	    const total_n_trials = training_stimuli_range1.length*reproduction_training_stimulus_repetitions + 
		  			training_stimuli_range2.length*reproduction_training_stimulus_repetitions  + 
		  			test_stimuli_range1.length*reproduction_testing_stimulus_repetitions + 
		  			test_stimuli_range2.length*reproduction_testing_stimulus_repetitions + 
		  			discrimination_training_stimuli.length*discrimination_training_stimulus_repetitions + 
		  			discrimination_test_stimuli.length*discrimination_testing_stimulus_repetitions; 
	    
	    // measure screen resolution and participants' distance from the screen; 
	    // resize stimuli accordingly in degrees of visual angle. current setting - 50 pixels are strethced to 1 dva
	    const virtual_chinrest = {
		    type: jsPsychVirtualChinrest,
		    blindspot_reps: 3,
		    resize_units: "deg",
		    pixels_per_unit: 50
	    };
	    
	    
	    // placeholder variables for subject, study, and sesion ids
	    let subject_id =  Math.round(Math.random()*100); //jsPsych.data.getURLVariable('PROLIFIC_PID');
	    let study_id = 'orientation_range';//jsPsych.data.getURLVariable('STUDY_ID');
	    let session_id = 1;//Math.round(Math.random())+1;// jsPsych.data.getURLVariable('SESSION_ID');
	    
	    // add above information to dataset
	    jsPsych.data.addProperties({
		    subject_id: subject_id,
		    study_id: study_id,
		    session_id: session_id
	    });
	    
	    // currently not using pixijs, but would be a good idea to do so
	    const pixi_flag = jsPsych.data.getURLVariable('pixi_flag') === '1' ? true : false;
	    
	    // lenght of the line used in the response in pixels	    
	    const line_length = 120; 
	    

	    // assign order of conditions based on subject and session ids
	    let test_stimuli_block1 = [];
	    let test_stimuli_block2 = [];
	    
	    if( (subject_id % 2==0 && session_id == 1) || (subject_id % 2!=0 && session_id == 2)) {
		    training_stimuli_block1 = training_stimuli_range1;
		    test_stimuli_block1 = test_stimuli_range1; 
		    training_stimuli_block2 = training_stimuli_range2;
		    test_stimuli_block2 = test_stimuli_range2; 
	    }
	    else if ( (subject_id % 2==0 && session_id == 2) || (subject_id % 2!=0 && session_id == 1)) {
		    training_stimuli_block1 = training_stimuli_range2;
		    test_stimuli_block1 = test_stimuli_range2; 
		    training_stimuli_block2 = training_stimuli_range1;
		    test_stimuli_block2 = test_stimuli_range1; 
	    };    
	    
	    // check what browser participants are using; specify minimum screen size requirements; do not allow mobile devices
	    const browser_check = {
		    type: jsPsychBrowserCheck,
		    minimum_width: 1500,
		    minimum_height: 750,
		    inclusion_function: (data) => {
			    return data.mobile === false
		    },
		    exclusion_message: (data) => {
			    if(data.mobile){
				    return '<p>You must use a desktop/laptop computer to participate in this experiment.</p>';
			    } 
		    },
		    on_finish: function (data) {
			    data.frame_duration = (1 / data.vsync_rate) * 1000;
			    let frame_duration = (1 / data.vsync_rate) * 1000;
		    }
	    };
	    
	    // Preload stimuli
	    // create list of files for preloading
    	    let all_gabors_range1 = [];
	    let all_gabors_range2 = [];
	    for (var i = 0; i < test_stimuli_range1.length; i++) {
		    all_gabors_range1.push(test_stimuli_range1[i].stimulus);
		    all_gabors_range2.push(test_stimuli_range2[i].stimulus);
	    };
	    const preload = {
		    type: jsPsychPreload,
		    images: [all_gabors_range1, all_gabors_range2, "gabor_stimuli_matching/gabor_ori15_phase0.05.png", "gabor_stimuli_matching/gabor_ori139_phase0.05.png", "correct_response_feedback.png", "incorrect_response_feedback.png"],
		    video: "response_instruction_video.mp4",
		    message: "Task loading",
		    max_load_time: 10000,
		    show_detailed_errors: true
	    };

	    let welcome_instructions_text = [];
	    if (session_id == 1) {
		    welcome_instructions_text = [
			    '<p>Welcome to the experiment.<br>You have volunteered to take part in a research study investigating individual differences in orienation perception. This study consists of 2 sessions.<br>'+
			    'By agreeing to take part in this experiment, you will be committing to 2 sessions. You have to complete the two sessions within 1 week.<br><br>'+
			    'In sesion 1, you will complete 2 different tasks and it will take you around 45 minutes to complete.<br>In session 2, you will complete one task, and it will take you around 30 minutes to complete.<br><br>'+
			    'This is session 1.</p>'
		    ];
	    } else if (session_id == 2) {
		    welcome_instructions_text = [
			    '<p>Welcome back to the experiment.<br>You have volunteered to take part in a research study investigating individual differences in orienation perception.<br>'+
			    'This study consists of 2 sessions, and this is session 2.<br>In this sesion, you will complete an orientation matching task which will take you around 30 minutes to complete.</p>'
		    ];
	    
	    };
	    
	    // welcome to experiment instructions
	    const welcome_instructions = {
		    type: jsPsychInstructions,
		    pages: welcome_instructions_text,
		    show_clickable_nav: true,
		    allow_backward: false
	    };
	    
	    // orientation reproduction instructions: practice 
	    const reproduction_practice_instructions = {
		    type: jsPsychInstructions,
		    pages: [
			    // stimulus instructions
			    '<p> You will now perform an orientation matching task.<br>'+
			    'Each trial will begin with the presentation of a fixation cross.<br>Keep looking at the fixation cross in the middle of the screen until it diseappers.<br><br>'+
			    'Then you will see a black and white grating like the one below.<br>'+
			    '<img src="gabor_stimuli_matching/gabor_ori15_phase0.05.png" width="200"></img></p>',
			    // response instructions
			    '<p>After the grating disappears, you will be presented with a black line.<br>'+
			    'Your task will be to rotate the line so that it is oriented the same way as the grating.<br>'+
			    'To rotate the line, you have to have move your mouse to the right and to the left.<br><br>'+
			    '<video width="800" controls> <source src="response_instruction_video.mp4" type="video/mp4"></video></p>',
			    // feedback instructions
			    '<p>Finally, you will receive feedback which will indicate the accuracy of your response<br>'+
			    'The white line shows the true orientation of the grating. The coloured line shows your reponse.<br>'+
			    'The further away the coloured line is from the white line, the bigger the difference between your response and the true orientation of the grating.<br>'+
			    'If the coloured line is green, that means your response was close to the true orientation of the grating.<br>'+
			    '<img src="correct_response_feedback.png" width="150"></img><br>'+
			    'If the coloured line is red, that means your response was not close to the true orientation of the grating.<br>'+
			    '<img src="incorrect_response_feedback.png" width="150"></img></p>',
			    '<p>The experiment is divided into 2 blocks. Each block starts with 6 practice examples so that you get used to the task.<br>The task will take you around 30 minutes to complete.</p>'
			    	    
		    ],
		    show_clickable_nav: true,
		    allow_backward: true
	    };
	    
	    let trial_counter = 0;
	    // orientation reproduction instructions: test block 1
	    const reproduction_test_instructions_block1 = {
		    type: jsPsychInstructions,
		    pages: [
			    '<p>This was the end of the practice examples. Now you will complete the main task.<br>During each trial, keep looking at the fixation cross in the middle of the screen.<br>Click Next to start.</p>'
		    ],
		    show_clickable_nav: true,
		    allow_backward: false
	    };

		// orientation reproduction instructions: test block 2
		const reproduction_practice_instructions_block2 = {
		    type: jsPsychInstructions,
		    pages: [
			    '<p>This is the start of the second block. You will now complete 6 practice examples.<br>During each trial, keep looking at the fixation cross in the middle of the screen.<br>Click Next to start.</p>'
		    ],
		    show_clickable_nav: true,
		    allow_backward: false
	    };
	    
	    // orientation reproduction instructions: test block 2
	    const reproduction_test_instructions_block2 = {
		    type: jsPsychInstructions,
		    pages: [
			    '<p><p>This was the end of the practice examples. Now you will complete the main task.<br>During each trial, keep looking at the fixation cross in the middle of the screen.<br>Click Next to start.</p>'
		    ],
		    show_clickable_nav: true,
		    allow_backward: false
	    };
	    	    
	    // Stimulus timings
	    let gabor_duration_ms = 200;
	    
	    let pre_stim = Math.round((Math.random()*(1-0.5) + 0.5)*1000);
	    let post_stim = 250;

	    let start_fixation_matching = 0;
	    let start_gabor = start_fixation_matching + pre_stim;
	    let end_gabor = start_gabor + gabor_duration_ms;
	    let end_fixation_matching = end_gabor + post_stim;
	    
	     
	    // display fixation cross followed by gabor
	    const test = {
		    type: jsPsychPsychophysics,
		    pixi: pixi_flag,
		    canvas_offsetY: 0,
		    canvas_height: 700,
		    response_type: 'key',
		    choices: ['NO_KEYS'],
		    on_start: function () {
			    pre_stim = 500;//Math.round((Math.random()*(1-0.5) + 0.5)*1000);
			    post_stim = 250;

			    start_fixation_matching = 0;
			    start_gabor = start_fixation_matching + pre_stim;
			    end_gabor = start_gabor + 400;
			    end_fixation_matching = end_gabor + post_stim; 
		    },
		    stimuli: [
			    // Fixation cross
			    {
				    obj_type: 'cross',
				    line_length: 25,
				    line_color: 'white',
				    line_width: 5,
				    is_frame: true,
				    show_start_frame: () => Math.round(start_fixation_matching/jsPsych.data.get().select('frame_duration').values[0]),
				    show_end_frame: () => Math.round(end_fixation_matching/jsPsych.data.get().select('frame_duration').values[0]), // Math.round((500+250)/((1 / jsPsych.data.get().select('vsync_rate').values[0]) * 1000)),

			    }, 
			    // Gabor
			    {
				    obj_type: 'image',
				    image_width: 200,
				    startY: 150,
				    file: jsPsych.timelineVariable('stimulus'), 
				    is_frame: true,
				    show_start_frame: () => Math.round(start_gabor/jsPsych.data.get().select('frame_duration').values[0]),
				    show_end_frame: () => Math.round(end_gabor/jsPsych.data.get().select('frame_duration').values[0]),
			    }], // These can be referenced using the jsPsych.currentTrial().stim_array array.
		    on_finish: function(data) {
			    // transform selected orientation to a number between 0 and 180
			    data.stimulus_file = jsPsych.getCurrentTrial().stim_array[1].file; 
			    console.log(end_gabor);
			    console.log(end_fixation_matching);
			    //data.stimulus_orientation = jsPsych.timelineVariable('orientation');
			    },
		   trial_duration: () => {return end_fixation_matching+250},
	    };
	    
	    // define objects needed for response display
	    
	    // circle outline
	    const circle_obj = {
		    obj_type: 'circle',
		    startX: 'center',
		    startY: 'center',
		    radius: 60,
		    line_color: 'white',
		    line_width: 5,
	    };
	    
	    // black line that participants can rotated; initial orientation set to random 
//!!NOTE: need to exclude correct orientation from possible starting points
	    const line_obj = {
		    obj_type: 'line',
		    line_length: 120,
		    line_color: 'black',
		    line_width: 5,
		    angle: function() {
			    	let initial_orientation = Math.round(Math.random()*180);
			    	while (initial_orientation <= jsPsych.timelineVariable('orientation') + 5 && initial_orientation >= jsPsych.timelineVariable('orientation') - 5) {
					initial_orientation = Math.round(Math.random()*180);
				}
			    	return initial_orientation;
			    },
	    }; 
	    
	    // initialize placeholder variables for position and movement start of the line
	    let prev_mouseX = null;
	    let mouse_move_start = false;
	    
	    // define response trial
	    // participants have to:
	    // 	(1) click their mouse to wake up the circle
	    //  (2) move their mouse left and right to change the orientation of the line
	    //  (3) click the mouse again to freeze the line
	    //  (4) press space to continue
	    const response = {
		    type: jsPsychPsychophysics,
		    pixi: pixi_flag,
		    canvas_offsetY: 0,
		    canvas_height: 700,
		    response_type: 'key',
		    choices: [' '],
		    prompt: 'Left-click to wake up mouse. Move mouse to the left or right to rotate the line.<br>When you are happy with the orientation of the line, left click to stop the line moving.Then press the spacebar to save your response.',
		    stimuli: [circle_obj, line_obj], // These can be referenced using the jsPsych.currentTrial().stim_array array.
		    mouse_down_func: function(event){
			    mouse_move_start = !mouse_move_start;
		    },
		    mouse_move_func: function(event){ // This function will be automatically added as the event listener of the canvas.
			    if (mouse_move_start === false) return;
			    if (prev_mouseX === null){
				    prev_mouseX = event.offsetX;
				    return
			    };
			    
			    // stim_array[0] means a circle, and stim_array[1] means a line.
			    if (event.offsetX > prev_mouseX){
				    jsPsych.getCurrentTrial().stim_array[1].angle += (event.offsetX - prev_mouseX)*0.2; // The angle changes by 0.5 degrees.
			    } else {
				    jsPsych.getCurrentTrial().stim_array[1].angle -= (prev_mouseX - event.offsetX)*0.2;
			    };
			    //jsPsych.getCurrentTrial().stim_array[1].angle =  event.offsetX*0.07;
			    
			    prev_mouseX = event.offsetX;
			    console.log(`current orientation: ${jsPsych.getCurrentTrial().stim_array[1].angle}`);
			    console.log(`current mouse position: ${event.offsetX }`);
		    },
		    on_finish: function(data) {
			    // progress trial counter
			    var curr_progress_bar_value = jsPsych.getProgressBarCompleted();
			    jsPsych.setProgressBar(curr_progress_bar_value + (1/total_n_trials));
			    trial_counter = trial_counter+1;
			    // transform selected orientation to a number between 0 and 180
			    var selected_orientation = jsPsych.getCurrentTrial().stim_array[1].angle;
			    var positive_orientation = [];
			    if (selected_orientation<0) {
				    var negative_multiplier = Math.ceil(Math.abs(selected_orientation)/360);
				    positive_orientation =  selected_orientation + 360*negative_multiplier;
			    } else {
				    positive_orientation =  selected_orientation; 
			    }
	 
			    var quadrant_angle = [];
			    if (positive_orientation >= 360) {
				    var positive_multiplier = Math.floor(positive_orientation /360);
				    quadrant_angle = positive_orientation - 360*positive_multiplier; 	
			    } else {
				    quadrant_angle = positive_orientation;
			    }

			    corrected_angle = [];
			    if (quadrant_angle>=0 && quadrant_angle<=90) {corrected_angle =  180 - quadrant_angle;}
			    else if (quadrant_angle>90 && quadrant_angle<=180) {corrected_angle = 180 - quadrant_angle;}
			    else if (quadrant_angle>180 && quadrant_angle<=270) {corrected_angle = 180 - (quadrant_angle - 180);}
			    else if (quadrant_angle>270 && quadrant_angle<=360) {corrected_angle = 360 - quadrant_angle;}

			    console.log(`selected orientation: ${selected_orientation}`);
			    console.log(`corrected orientation: ${corrected_angle}`);
			    console.log(`stimulus orientation:  ${jsPsych.timelineVariable('orientation')}`);
			    	    
			    // calculate error between stimulus and response
			    // first transform stimulus orientation to be between 0 and 90 degrees
			    //let corrected_stimulus = [];
			    //if (jsPsych.timelineVariable('orientation')>90) {corrected_stimulus = 180 - jsPsych.timelineVariable('orientation');}
			    //else {corrected_stimulus = jsPsych.timelineVariable('orientation');}
			    let corrected_stimulus = jsPsych.timelineVariable('orientation');
			    let error = [];
			    error = Math.abs(corrected_stimulus-corrected_angle);
			    if (error>90) {
				    error = 180 - error;
			    }
			    console.log(`error between stimulus and response: ${error}`);
			    
			    // define colour of feedback line: green if response is close to the stimulus; red if it is not
			    var feedback_colour = [];
			    if (Math.abs(error) <= 3.5) { feedback_colour = 'green';}
			    else {feedback_colour = 'red';} 
			    
			    data.corrected_stimulus = corrected_stimulus;
			    data.selected_response = selected_orientation;
			    data.corrected_response = corrected_angle;
			    data.feedback_colour = feedback_colour;
			    data.error = error;
		    }
	    };
	    
	    // define feedback display: consists of a circle, a white line showing the true gabor orientation, 
	    // and a coloured line showing the orientation selected by the participant
	    const feedback= {
		    type: jsPsychPsychophysics,
		    pixi: pixi_flag,
		    canvas_offsetY: 0,
		    canvas_height: 700,
		    response_type: 'key',
		    choices: [' '],
		    prompt: [],
		    on_start: function(trial) {
			    if (jsPsych.data.get().last(1).values()[0].feedback_colour == 'green') {
				    trial.prompt = 'The white line shows the true orienation of the grating. The coloured line shows your response.<br>If the line is green, you were close to the true orientation of the grating. Press the spacebar to continue.'    
			    }
			    else {
				    trial.prompt = 'The white line shows the true orienation of the grating. The coloured line shows your response.<br>If the line is red, you were not close to the true orientation of the grating. Press the spacebar to continue.'
			    }
			    
		    
		    },
		    stimuli: [circle_obj, 
			      // response line
			      {
				      obj_type: 'line',
				      line_length: 120,
				      line_color: function () {return jsPsych.data.get().last(1).values()[0].feedback_colour},
				      line_width: 5,
				      angle: function () {return jsPsych.data.get().last(1).values()[0].selected_response},
			      },
			      // stimulus line
			      {
				      obj_type: 'line',
				      line_length: 120,
				      line_color: 'white',
				      line_width: 5,
				      angle: function () {return 180 - jsPsych.timelineVariable('orientation')}	 
			      }   
			     ],
	    };
	    	    	    
// orientation discrimination task
	    
    
	    // 	orientation discrimination instructions: practice 
	    const discrimination_practice_instructions = {
		    type: jsPsychInstructions,
		    pages: [
			    // stimulus instructions
			    '<p> You will now perform an orientation discrimination task.<br>'+
			    'When a trial starts, you will see a pair of black and white gratings.<br>'+
			    'This will be follows by another pair of black and white gratins.<br>'+
			    'Your task will be to report whether the gratings in the first or second pair were more similar in orientation.<br>'+
			    'You will then receive feedback whether your response was correct.<br><br></p>'   	  
			    //'You will first complete a practice block. Click Next to start the task. </p>'   	    
		    ],
		    show_clickable_nav: true,
		    allow_backward: false
	    };
	    
	    // 	orientation discrimination instructions: test 
	    const discrimination_test_instructions = {
		    type: jsPsychInstructions,
		    pages: [
			    // stimulus instructions
			    '<p> You will now complete a test block.<br>'+
			    'On each trial you will see two pairs of gratings one after the other.<br><br>'+
			    'Your task will be to report whether the gratings in the first or second pair were more similar in orientation.<br>'+
			    'Click Next to start the task. </p>'   	//You will not receive feedback in the test block.    
		    ],
		    show_clickable_nav: true,
		    allow_backward: false
	    };	    
	    

	    	    

	    // Define stimulus duration and starting itis (updated on every trial)
	    let stim_duration_ms = 400;
	    
	    let pre_iti = (Math.random()*(1.2-0.5) + 0.5)*1000;
	    let stim_iti = (Math.random()*(1.2-0.5) + 0.5)*1000;
	    let post_iti = (Math.random()*(1.2-0.5) + 0.5)*1000;
	    let start_fixation = 0;
	    let start_first_pair = start_fixation + pre_iti;
	    let end_first_pair = start_first_pair + stim_duration_ms;
	    let start_second_pair = end_first_pair + stim_iti;
	    let end_second_pair = start_second_pair + stim_duration_ms;
	    let end_fixation = end_second_pair + post_iti;
	   
	    // Define stimulus presentation structure: fixation appears, first pair of gabors, second pair of gabors, fixaction disappears
	    let discrimination_trial = {
		    type: jsPsychPsychophysics,
		     on_start: function () {
		   	    pre_iti = Math.round((Math.random()*(1.2-0.5) + 0.5)*1000);
			    stim_iti = Math.round((Math.random()*(1.2-0.5) + 0.5)*1000);
			    post_iti = Math.round((Math.random()*(1.2-0.5) + 0.5)*1000);

			    start_fixation = 0;
			    start_first_pair = start_fixation + pre_iti;
			    end_first_pair = start_first_pair + stim_duration_ms;
			    start_second_pair = end_first_pair + stim_iti;
			    end_second_pair = start_second_pair + stim_duration_ms;
			    end_fixation = end_second_pair + post_iti;
			    console.log(end_second_pair);
			    console.log(end_fixation);

		    },
		    stimuli: [
			    // fixation cross
			    {
			  	      obj_type: 'cross',
				      line_length: 25,
				      line_color: 'white',
				      line_width: 5,
				      startX: 'center',
				      is_frame: true,
				      show_start_frame: () => start_fixation,
				      show_end_frame: () => Math.round(end_fixation/jsPsych.data.get().select('frame_duration').values[0]),
			    },
			    // first pair, left gabor
			    {
			    	      obj_type: 'image',
				      file: jsPsych.timelineVariable('first_left_gabor_filename'), 
				      startX: 300,
				      image_width: 200,
				      is_frame: true,
				      show_start_frame: () => Math.round(start_first_pair/jsPsych.data.get().select('frame_duration').values[0]),
				      show_end_frame: () => Math.round(end_first_pair/jsPsych.data.get().select('frame_duration').values[0]),
			    },
			    // first pair, right gabor
		    	    {
			    	      obj_type: 'image',
				      file: jsPsych.timelineVariable('first_right_gabor_filename'), 
				      startX: 700,
				      image_width: 200,
				      is_frame: true,
				      show_start_frame: () => Math.round(start_first_pair/jsPsych.data.get().select('frame_duration').values[0]),
				      show_end_frame: () => Math.round(end_first_pair/jsPsych.data.get().select('frame_duration').values[0]),
			    },
			    // second pair, left gabor
			    {
			    	      obj_type: 'image',
				      file: jsPsych.timelineVariable('second_left_gabor_filename'), 
				      startX: 300,
				      image_width: 200,
				      is_frame: true,
				      show_start_frame: () => Math.round(start_second_pair/jsPsych.data.get().select('frame_duration').values[0]),
				      show_end_frame: () => Math.round(end_second_pair/jsPsych.data.get().select('frame_duration').values[0]),
			    },
			    // second pair, right gabor
		    	    {
			    	      obj_type: 'image',
				      file: jsPsych.timelineVariable('second_right_gabor_filename'), 
				      startX: 700,
				      image_width: 200,
				      is_frame: true,
				      show_start_frame: () => Math.round(start_second_pair/jsPsych.data.get().select('frame_duration').values[0]),
				      show_end_frame: () => Math.round(end_second_pair/jsPsych.data.get().select('frame_duration').values[0]),
			    },
		    ],
		    canvas_width: 1000,
		    canvas_height: 800,
		    trial_duration: () => {return end_fixation+100},
		    response_ends_trial: false,
		    background_color: '#808080',
		    on_finish: function (data) {
			    data.first_left_orientation = jsPsych.timelineVariable('first_left_gabor_orientation') ;
		            data.first_right_orientation = jsPsych.timelineVariable('first_right_gabor_orientation') ;
			    data.second_left_orientation = jsPsych.timelineVariable('second_left_gabor_orientation') ;
			    data.second_right_orientation = jsPsych.timelineVariable('second_right_gabor_orientation') ;
			    data.difference_first_pair = Math.abs(jsPsych.timelineVariable('first_left_gabor_orientation') - jsPsych.timelineVariable('first_right_gabor_orientation'));
			    data.difference_second_pair = Math.abs(jsPsych.timelineVariable('second_left_gabor_orientation') - jsPsych.timelineVariable('second_right_gabor_orientation'));
			    
			    if (data.difference_first_pair < data.difference_second_pair) {
				    data.correct_response = 0;
			    } else {
				    data.correct_response = 1;
			    } 
			    console.log(data.correct_response);
		    }
	    };
	    
	    let discrimination_response = {
		    type: jsPsychHtmlButtonResponse,
		    stimulus: '<p>Which pair was closer together?</p>',
		    choices: ['First', 'Second'],
		    on_finish: function (data) {
			    // progress trial counter 
			    trial_counter = trial_counter+1;
			    var curr_progress_bar_value = jsPsych.getProgressBarCompleted();
        		    jsPsych.setProgressBar(curr_progress_bar_value + (1/totral_n_trials));
			    var stim_trial_id = data.trial_index - 1;
			    data.correct_response = jsPsych.data.get().trials[stim_trial_id].correct_response;
			    // Score the response as correct or incorrect.
			    if (data.response == jsPsych.data.get().trials[stim_trial_id].correct_response) {
				    data.correct = true;
			    } else {
				    data.correct = false;
			    }
			    console.log(data.correct);
		    }
	    };
	    // Feedback in training phase
	    var training_feedback = {
		    type: jsPsychHtmlKeyboardResponse,
		    stimulus: function () {
			    // The feedback stimulus is a dynamic parameter because we can't know in advance whether
			    // the stimulus should be 'correct' or 'incorrect'.
			    // Instead, this function will check the accuracy of the last response and use that information to set
			    // the stimulus value on each trial.
			    var last_trial_correct_resp = jsPsych.data.get().last(1).values()[0].correct_response;
			    var last_trial_correct = jsPsych.data.get().last(1).values()[0].correct;
			    if (last_trial_correct) {
				    return "<p>That was the correct answer!</p><p>Press space to continue.</p>"; // the parameter value has to be returned from the function
			    } else if (last_trial_correct == 0 && last_trial_correct_resp == 0) {
				    return "<p>That wasn't the correct answer.</p><p>The gratings in the first pair were closer in orientation.</p><p>Press space to continue.</p>"; // the parameter value has to be returned from the function
			    } else if (last_trial_correct == 0 && last_trial_correct_resp == 1) {
				    return "<p>That wasn't the correct answer.</p><p>The gratings in the second pair were closer in orientation.</p><p>Press space to continue.</p>"; // the parameter value has to be returned from the function
			    }
		    },
		    //trial_duration: 5000,
		    choices: [' '],
		    response_ends_trial: true,
        };
	    
	   // Feedback in testing phase
	    var testing_feedback = {
		    type: jsPsychHtmlKeyboardResponse,
		    stimulus: function () {
			    // The feedback stimulus is a dynamic parameter because we can't know in advance whether
			    // the stimulus should be 'correct' or 'incorrect'.
			    // Instead, this function will check the accuracy of the last response and use that information to set
			    // the stimulus value on each trial.
			    var last_trial_correct_resp = jsPsych.data.get().last(1).values()[0].correct_response;
			    var last_trial_correct = jsPsych.data.get().last(1).values()[0].correct;
			    console.log(last_trial_correct_resp);
			    console.log(last_trial_correct);
			    if (last_trial_correct) {
				    return "<p>Correct</p><p>Press space to continue.</p>"; // the parameter value has to be returned from the function
			    } else if (last_trial_correct == 0 && last_trial_correct_resp == 0) {
				    return "<p>Incorrect</p><p>Press space to continue.</p>"; // the parameter value has to be returned from the function
			    } else if (last_trial_correct == 0 && last_trial_correct_resp == 1) {
				    return "<p>Incorrect</p><p>Press space to continue.</p>"; // the parameter value has to be returned from the function
			    }
            },
            //trial_duration: 5000,
            choices: [' '],
            response_ends_trial: true,
        };
	    
	    // timer for breaks    
	    const mkTimer_middle_matching = {
		    type: jsPsychHtmlKeyboardResponse,
		    stimulus: '<div style="font-size: 25px"><p>The next part of the experiment will start in</p>'
		    + '<div style="font-size: 50px; color: white"><p><span id="clock">0:10</span></div></p></div>',
		    choices: ['q'],
		    trial_duration: 10500,
		    on_load: function(){
			    // add a keyboard listener 
			    document.addEventListener('keydown', function(e){
				    if (e.key == 'q'){
					    window.clear_timer = -1;
				    }
			    });
			    window.clear_timer = 1;
			    var wait_time = 1 * 10 * 1000; // in milliseconds
			    var start_time = performance.now();
			    var interval = setInterval(function(){
				    var time_left = wait_time - (performance.now() - start_time);
				    var minutes = Math.floor(time_left / 1000 / 60);
				    var seconds = Math.floor((time_left - minutes*1000*60)/1000);
				    var seconds_str = seconds.toString().padStart(2,'0');
				    if(time_left <= 0){
					    document.querySelector('#clock').innerHTML = "0:00";
					    window.clear_timer = -1;
				    };
				    if(window.clear_timer > 0){
					    document.querySelector('#clock').innerHTML = minutes + ':' + seconds_str
				    } else {
					    clearInterval(interval);
				    };
			    }, 250)
			    },
		    on_finish: function(){
			    window.clear_timer = -1;          
		    }
	    };
	    
	    const mkTimer_end_matching = {
		    type: jsPsychHtmlKeyboardResponse,
		    stimulus: '<div style="font-size: 25px"><p>The next part of the experiment will start in</p>'
		    + '<div style="font-size: 50px; color: white"><p><span id="clock">0:30</span></div></p></div>',
		    choices: ['q'],
		    trial_duration: 30500,
		    on_load: function(){
			    // add a keyboard listener 
			    document.addEventListener('keydown', function(e){
				    if (e.key == 'q'){
					    window.clear_timer = -1;
				    }
			    });
			    window.clear_timer = 1;
			    var wait_time = 1 * 30 * 1000; // in milliseconds
			    var start_time = performance.now();
			    var interval = setInterval(function(){
				    var time_left = wait_time - (performance.now() - start_time);
				    var minutes = Math.floor(time_left / 1000 / 60);
				    var seconds = Math.floor((time_left - minutes*1000*60)/1000);
				    var seconds_str = seconds.toString().padStart(2,'0');
				    if(time_left <= 0){
					    document.querySelector('#clock').innerHTML = "0:00";
					    window.clear_timer = -1;
				    };
				    if(window.clear_timer > 0){
					    document.querySelector('#clock').innerHTML = minutes + ':' + seconds_str
				    } else {
					    clearInterval(interval);
				    };
			    }, 250)
			    },
		    on_finish: function(){
			    window.clear_timer = -1;          
		    }
	    };
	    
	    
	    // define alarm that signals end of break
	    const alarm = {
		    type: jsPsychHtmlButtonResponse,//jsPsychAudioButtonResponse,
		    stimulus: 'This is the end of the break. Please continue the experiment.',//'Alarm.mp3',
		    choices: ['Continue'],
		    //prompt: 'This is the end of the break. Please continue the experiment.'	
	    };
	    
	    // Cursor hidden and showing
	    const hide_cursor = {
		    type: jsPsychCallFunction,
		    func: function() {
			    document.body.style.cursor= "none";
		    }
	    };
	    
	    const show_cursor = {
		    type: jsPsychCallFunction,
		    func: function() {
			    document.body.style.cursor= "auto";
		    }
	    };
	    
	    // Discrimination task timeline
	    // Training procedure
	    let discrimination_training_procedure = {
		    timeline: [discrimination_trial,  discrimination_response, training_feedback],  //Interval1_Training, Interval2_Training,
		    timeline_variables: discrimination_training_stimuli,
		    repetitions: 1,
		    randomize_order: true
	    };
	    
	    // Testing procedure
	    let discrimination_testing_procedure = {
		    timeline: [discrimination_trial,  discrimination_response, testing_feedback],  //Interval1_Training, Interval2_Training,
		    timeline_variables: discrimination_test_stimuli,
		    repetitions: 2,
		    randomize_order: true
	    };
	    
	    // Full discrimination task procedure
	    let discrimination_task = {
		    timeline: [discrimination_practice_instructions, discrimination_training_procedure, discrimination_test_instructions, discrimination_testing_procedure]
	    };
	    
	    // Reproduction task timeline
	    // Training procedure
	    let reproduction_training_procedure_block1 = {
		    timeline: [hide_cursor, test, show_cursor, response, feedback],
	            timeline_variables: training_stimuli_block1,
		    randomize_order: true,
		    repetitions: 3
	    };

	    let reproduction_training_procedure_block2 = {
		    timeline: [hide_cursor, test, show_cursor, response, feedback],
	            timeline_variables: training_stimuli_block2,
		    randomize_order: true,
		    repetitions: 3
	    };
	    
	    // Testing procedure, divided in 2 blocks
	    let reproduction_testing_procedure_block1 = {
		    timeline: [hide_cursor, test, show_cursor, response, feedback],
		    timeline_variables: test_stimuli_block1,
		    randomize_order: true,
		    repetitions: 2
	    };
	    
	    let reproduction_testing_procedure_block2 = {
		    timeline: [hide_cursor, test, show_cursor, response, feedback],
		    timeline_variables: test_stimuli_block2,
		    randomize_order: true,
		    repetitions: 2
	    };
	    
	  	    
	    // Full reproduction task procedure
	    let reproduction_task = {
		    timeline: [reproduction_practice_instructions, reproduction_training_procedure_block1, 
			       reproduction_test_instructions_block1, reproduction_testing_procedure_block1, mkTimer_middle_matching, alarm,
			       reproduction_practice_instructions_block2, reproduction_training_procedure_block2, reproduction_test_instructions_block2, reproduction_testing_procedure_block2]
	    };
	    
	    // define timeline for the two sessions
	    // session 1: orientation matching followed by orientation discrimination
	    // session 2: orientation matching only
	    
	    // end of session messages
	    let end_session1 = {
		    type: jsPsychHtmlButtonResponse,
		    stimulus: '<p>This is the end of session 1.<br>Please press the button below to save your data. Please remember to return to the experiment and complete session 2 within 7 days.<p/><p>Thank you for your participation!</p>', 
		    choices: ['Save data'],
	    };
		    
	     let end_session2 = {
		    type: jsPsychHtmlButtonResponse,
		    stimulus: '<p>This is the end of session 2.<br>Please press the button below to save your data.<p/><p>Thank you for completing the experiment!</p>', 
		    choices: ['Save data'],
	     };
		        
		     
	    let session_1_timeline = {
		    timeline: [ 
			    browser_check,
			    preload,
			    //virtual_chinrest,	 
			    welcome_instructions,
			    reproduction_task,
			    mkTimer_end_matching,
			    alarm,
			    discrimination_task,
				end_session1]    
	    };
	    
	    let session_2_timeline = {		    
		    timeline: [ 
			    browser_check,
			    preload,
			    //virtual_chinrest,	 
			    welcome_instructions,
			    reproduction_task,
				end_session2
			    ]    
	    };
	    
	    // select timeline for current session
	    let current_session_timeline = [];
	    if (session_id == 1) {
		    current_session_timeline = session_1_timeline;
	    } else if (session_id == 2) {
		    current_session_timeline = session_2_timeline;
	    };
	    
	    //run experiment
	    jsPsych.run([
		    current_session_timeline	    
	    ]);

	</script>
</html>
